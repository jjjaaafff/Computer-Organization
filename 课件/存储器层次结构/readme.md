# 存储器层次结构

* 局部性原理

    * 程序的时间局部性：重复使用最近被访问的数据项的趋势
    * 程序的空间局部性：访问与最近访问过的数据项地址空间相近的数据项趋势

* 缓存Cache

    * 作用：提升CPU访问存储器的性能
    * 当处理器在cache中找到要访问的数据时，称为Cache命中  
    当处理器在Cache中找不到要访问的数据时，称为Cache缺失  
    块：Cache中的存储最小单位，一般是几个字节  
    * 一个从主存来的块，可以放在cache中的哪里？

        * 直接映射：  
        根据cache块的总数，对地址取余，放在余数对应的cache中  
        即块的确定为（块地址） MOD （Cache中的块数）  
        块地址 = 字节地址/每块字节数  
        方法简单，但容易冲突
        * 全相联映射：  
        哪里空放在哪里。不易冲突但映射方法复杂且不好找
        * 组相联映射  
        对块进行分组，同组内为全相联映射  
        若一个组内有n个块，这称为n路组相联   
        即组的确定为（块地址）MOD（Cache的组数）  
    * 如果某一块放在Cache中，如何找到它？  
    在cache中增加一组标记位，标记中包含地址信息，可用来判断  
    标记位为地址的高位去除索引位(索引位数为log块数)  
    同时还要在标志中增加一个有效位，标明该块是否有效  
    若有效位未被置位，这不能进行匹配。如刚上电Cache为空或作废后  

    * 如果cache缺失，哪个块应该被替换？  
        * 缺失时，cache中没有找到想要的地址，要从主存中取出来放到cache中。
        * 直接映射时，不需要考虑这个问题，替换的块是确定的
        * 全相联或组相联时，发生缺失有三种替换策略
          1. 随机替换：为了均匀分配，随机选一块替换
          2. 最近最少使用(LRU)：替换最近最少使用的块(局部性原理推论)
          3. 先进先出替换：最早进入Cache的块作为替换块
        * 大容量cache三种替换差不多，小容量cache，LRU>FIFO>随机替换
    * 写操作时会发生什么？  
    写有两种方式，写直达法和写回法  
      * 写直达：信息同时写到cache和低一层存储器块中
      * 写回：信息只写入cache，只有当cache该块被替换时，才写回到主存
    * 发生写缺失时，两种策略，写分配和不按写分配
        * 写分配：将内存中的块读到cache中，然后执行写
        * 不按写分配：仅修改存储器的数据，不影响当前cache中的内容

* Cache性能评价  
    * 平均存储器访问时间AMAT，=命中时间+缺失率*缺失代价
    * 每条指令的平均停顿时间，=每条指令缺失次数*缺失代价
    * 停顿时间=(AMAT-命中时间1)*每条指令平均访存次数

* 多级cache  
极大降低缺失代价
  * 一级Cache的全局缺失率仍为缺失率
  * 二级cache的全局缺失率为两个cache局部缺失率之积，局部为缺失次数比
  * 存储器访问时间=命中时间1+缺失率1*(命中时间2+缺失率2*缺失代价2)
  * 存储器停顿周期=缺失次数1*命中时间2+缺失次数2\*缺失代价2


* 虚拟存储器
    * 产生原因
        1. 主存(Main memory内存)空间是有限的，更大的空间在硬盘HD里(但很慢)。而每个程序都希望有足够大的空间可以支配，即超过主存容量。
        2. 平常程序都存在硬盘(磁盘)里，主存中只用放各个程序的活跃部分
    * 目的：解决“大”的程序寻址空间和“小”的真实物理主存空间的矛盾
    * 总体原理  
    对每个程序的各个block位置进行指针记录映射。APP给出虚拟地址，通过记录的页表查询在哪里。若指向内存则直接到该处取数据；若指向硬盘(缺页)，则将硬盘数据输入到主存中，再将指针指向主存位置并读取。
    * 设计要求
        * 在硬件上，CPU要能够判断当前代码是在主存上还是硬盘上。发现在硬盘上时，要将控制权转移至操作系统。
        * 在软件上，发生缺页时，操作系统要能将硬盘上的数据搬运至主存中，完成后返还控制权。操作系统负责维护页表
    * 特点
        1. 每个APP都有一个页表，页表本身太大了以至于还要分页。即一部分放在硬盘上一部分放在内存中。因此将频繁访问的页表放在cache中，即加速对页表的访问查询
        2. 若不进行快表加速的话，访存相关的每个操作要访问存储器两次。第一次访问存储器中的页表获得实际地址，第二次访问存储器中的该实际地址
    * 几个问题
        * 硬盘上的块可以放在内存中的什么位置？   全相联
        * 如何在内存中查找一个块？  利用页表进行记录
        * 发生虚拟存储器缺失时，替换哪一个块？ LRU
        * 写操作如何进行？ 写回法
        * 写回法什么时候回出错？ 突然断电，主存数据修改了但还没有写入硬盘。
    * 快表(TLB)
        * 用于存放频繁访问的页表的cache称为快表(TLB)
        * 采用全相联映射。称为相联存储器，因为是按内容去查找\寻址
        * 仅仅由CPU进行控制
        * 若在快表中找到，则直接访问。若缺失则需要访问存储器中的页表。

