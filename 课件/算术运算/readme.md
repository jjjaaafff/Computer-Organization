# 算术运算

* 加法器  
一个64bit的加法器，可拆成8个8bit的加法器等等  
即用一条指令完成八次八位加法运算  
可以被并行运算  

* 饱和运算  
一旦溢出出现，结果取可表达的最大值  
如两个大数相加，结果表示为最大的数，而不是负数了  

* 乘法  
  * 运算过程  
  每次右移乘数一位，得到最右边的一位。如果是1则加上被乘数，如果是0则什么也不做。然后被乘数左移一位。直到乘数移完结束  
  * 将数左移两位相当于把这个数乘四  
  
  若硬件不支持，则需要利用软件实现  
  可以并行加速，可以利用流水线

* 除法  
首先需要除零检测，然后利用竖式方式硬件实现计算

  * 运算过程  
  首先分子右侧加32位零保存，分母不变放在余数寄存器。  
  每次用分母减分子，如果差大于零，商左移一位且最右置1；如果差小于零，恢复，商左移一位且最右置零。然后分子右移一位。直到分子移完  
  * 不能并行加速。  
  * 如果想要在一个clock中生成商和余数，可以吗？  
代价太大了，可以通过提前建立好一个表来直接查找，输入为64位分子和32位分母总共96位。输出为32位商和32位余数，表太大了
  * 包括sin，cos的运算同样需要利用查表实现


* 浮点数  
    对于不同bit的电脑，运行同一个程序时得到的结果精度相同。  
    浮点数两种表示形式
    * 单精度(32bit)：1位符号位，8位指数位，23位系数位  
    但有效位数为24位，由于科学计数的规定，多了一位省略的1  
    转为十进制时约为6位小数
      * 指数位表示是无符号数，实际指数大小为8位指数的值减去偏移量127  
    或者说，8位记录的是实际指数大小加上偏移量127(双精度1023)  
      * 单精度表示范围  
        指数8位保留8个1和8个0。最小是1-127=-126，最大是11111110 = 254-127=127。即2^(-126) ~ 2^(127)  
        系数最小全是0，只剩一个隐含的1  
        系数最大全是1，整体约等于2
        
    * 双精度(64bit)：1位符号位，11位指数位，52位系数位  
        转为十进制时约为16位小数
        * 表示的特殊情况
          1. 当指数位全为0时，隐藏系数位为0
          2. 当指数位全为1，系数位全为0时，表示无穷大
          3. 当指数位全为1，系数位不全为0时，表示不是一个数NaN
    * 浮点加法运算  
    将指数小的数向指数大的数对齐，使得指数位相同，对系数进行计算规范
    可直接使用alu，可以流水线化处理
    * 乘法运算：利用软件循环实现，或者利用专门的硬件的浮点运算器FP  
    * 支持算术运算时CPU分两类  
    一类是整型运算，一类是浮点运算(主频相对比较低)


